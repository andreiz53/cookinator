// Code generated by mockery v2.51.1. DO NOT EDIT.

package database

import (
	context "context"

	database "github.com/andreiz53/cookinator/database/handlers"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// CreateFamily provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateFamily(ctx context.Context, arg database.CreateFamilyParams) (database.Family, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateFamily")
	}

	var r0 database.Family
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateFamilyParams) (database.Family, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateFamilyParams) database.Family); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Family)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.CreateFamilyParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateFamily_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFamily'
type MockStore_CreateFamily_Call struct {
	*mock.Call
}

// CreateFamily is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.CreateFamilyParams
func (_e *MockStore_Expecter) CreateFamily(ctx interface{}, arg interface{}) *MockStore_CreateFamily_Call {
	return &MockStore_CreateFamily_Call{Call: _e.mock.On("CreateFamily", ctx, arg)}
}

func (_c *MockStore_CreateFamily_Call) Run(run func(ctx context.Context, arg database.CreateFamilyParams)) *MockStore_CreateFamily_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.CreateFamilyParams))
	})
	return _c
}

func (_c *MockStore_CreateFamily_Call) Return(_a0 database.Family, _a1 error) *MockStore_CreateFamily_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateFamily_Call) RunAndReturn(run func(context.Context, database.CreateFamilyParams) (database.Family, error)) *MockStore_CreateFamily_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIngredient provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateIngredient(ctx context.Context, arg database.CreateIngredientParams) (database.Ingredient, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateIngredient")
	}

	var r0 database.Ingredient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateIngredientParams) (database.Ingredient, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateIngredientParams) database.Ingredient); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Ingredient)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.CreateIngredientParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateIngredient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIngredient'
type MockStore_CreateIngredient_Call struct {
	*mock.Call
}

// CreateIngredient is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.CreateIngredientParams
func (_e *MockStore_Expecter) CreateIngredient(ctx interface{}, arg interface{}) *MockStore_CreateIngredient_Call {
	return &MockStore_CreateIngredient_Call{Call: _e.mock.On("CreateIngredient", ctx, arg)}
}

func (_c *MockStore_CreateIngredient_Call) Run(run func(ctx context.Context, arg database.CreateIngredientParams)) *MockStore_CreateIngredient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.CreateIngredientParams))
	})
	return _c
}

func (_c *MockStore_CreateIngredient_Call) Return(_a0 database.Ingredient, _a1 error) *MockStore_CreateIngredient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateIngredient_Call) RunAndReturn(run func(context.Context, database.CreateIngredientParams) (database.Ingredient, error)) *MockStore_CreateIngredient_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRecipe provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateRecipe(ctx context.Context, arg database.CreateRecipeParams) (database.Recipe, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateRecipe")
	}

	var r0 database.Recipe
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateRecipeParams) (database.Recipe, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateRecipeParams) database.Recipe); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Recipe)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.CreateRecipeParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateRecipe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRecipe'
type MockStore_CreateRecipe_Call struct {
	*mock.Call
}

// CreateRecipe is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.CreateRecipeParams
func (_e *MockStore_Expecter) CreateRecipe(ctx interface{}, arg interface{}) *MockStore_CreateRecipe_Call {
	return &MockStore_CreateRecipe_Call{Call: _e.mock.On("CreateRecipe", ctx, arg)}
}

func (_c *MockStore_CreateRecipe_Call) Run(run func(ctx context.Context, arg database.CreateRecipeParams)) *MockStore_CreateRecipe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.CreateRecipeParams))
	})
	return _c
}

func (_c *MockStore_CreateRecipe_Call) Return(_a0 database.Recipe, _a1 error) *MockStore_CreateRecipe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateRecipe_Call) RunAndReturn(run func(context.Context, database.CreateRecipeParams) (database.Recipe, error)) *MockStore_CreateRecipe_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateUser(ctx context.Context, arg database.CreateUserParams) (database.User, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateUserParams) (database.User, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.CreateUserParams) database.User); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.CreateUserParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockStore_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.CreateUserParams
func (_e *MockStore_Expecter) CreateUser(ctx interface{}, arg interface{}) *MockStore_CreateUser_Call {
	return &MockStore_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, arg)}
}

func (_c *MockStore_CreateUser_Call) Run(run func(ctx context.Context, arg database.CreateUserParams)) *MockStore_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.CreateUserParams))
	})
	return _c
}

func (_c *MockStore_CreateUser_Call) Return(_a0 database.User, _a1 error) *MockStore_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateUser_Call) RunAndReturn(run func(context.Context, database.CreateUserParams) (database.User, error)) *MockStore_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFamily provides a mock function with given fields: ctx, id
func (_m *MockStore) DeleteFamily(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFamily")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_DeleteFamily_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFamily'
type MockStore_DeleteFamily_Call struct {
	*mock.Call
}

// DeleteFamily is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) DeleteFamily(ctx interface{}, id interface{}) *MockStore_DeleteFamily_Call {
	return &MockStore_DeleteFamily_Call{Call: _e.mock.On("DeleteFamily", ctx, id)}
}

func (_c *MockStore_DeleteFamily_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_DeleteFamily_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_DeleteFamily_Call) Return(_a0 error) *MockStore_DeleteFamily_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_DeleteFamily_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockStore_DeleteFamily_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIngredient provides a mock function with given fields: ctx, id
func (_m *MockStore) DeleteIngredient(ctx context.Context, id int32) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIngredient")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_DeleteIngredient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIngredient'
type MockStore_DeleteIngredient_Call struct {
	*mock.Call
}

// DeleteIngredient is a helper method to define mock.On call
//   - ctx context.Context
//   - id int32
func (_e *MockStore_Expecter) DeleteIngredient(ctx interface{}, id interface{}) *MockStore_DeleteIngredient_Call {
	return &MockStore_DeleteIngredient_Call{Call: _e.mock.On("DeleteIngredient", ctx, id)}
}

func (_c *MockStore_DeleteIngredient_Call) Run(run func(ctx context.Context, id int32)) *MockStore_DeleteIngredient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockStore_DeleteIngredient_Call) Return(_a0 error) *MockStore_DeleteIngredient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_DeleteIngredient_Call) RunAndReturn(run func(context.Context, int32) error) *MockStore_DeleteIngredient_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRecipe provides a mock function with given fields: ctx, id
func (_m *MockStore) DeleteRecipe(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRecipe")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_DeleteRecipe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRecipe'
type MockStore_DeleteRecipe_Call struct {
	*mock.Call
}

// DeleteRecipe is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) DeleteRecipe(ctx interface{}, id interface{}) *MockStore_DeleteRecipe_Call {
	return &MockStore_DeleteRecipe_Call{Call: _e.mock.On("DeleteRecipe", ctx, id)}
}

func (_c *MockStore_DeleteRecipe_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_DeleteRecipe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_DeleteRecipe_Call) Return(_a0 error) *MockStore_DeleteRecipe_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_DeleteRecipe_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockStore_DeleteRecipe_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, id
func (_m *MockStore) DeleteUser(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockStore_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) DeleteUser(ctx interface{}, id interface{}) *MockStore_DeleteUser_Call {
	return &MockStore_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, id)}
}

func (_c *MockStore_DeleteUser_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_DeleteUser_Call) Return(_a0 error) *MockStore_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_DeleteUser_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockStore_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetFamilies provides a mock function with given fields: ctx
func (_m *MockStore) GetFamilies(ctx context.Context) ([]database.Family, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFamilies")
	}

	var r0 []database.Family
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.Family, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.Family); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Family)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetFamilies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFamilies'
type MockStore_GetFamilies_Call struct {
	*mock.Call
}

// GetFamilies is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetFamilies(ctx interface{}) *MockStore_GetFamilies_Call {
	return &MockStore_GetFamilies_Call{Call: _e.mock.On("GetFamilies", ctx)}
}

func (_c *MockStore_GetFamilies_Call) Run(run func(ctx context.Context)) *MockStore_GetFamilies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_GetFamilies_Call) Return(_a0 []database.Family, _a1 error) *MockStore_GetFamilies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetFamilies_Call) RunAndReturn(run func(context.Context) ([]database.Family, error)) *MockStore_GetFamilies_Call {
	_c.Call.Return(run)
	return _c
}

// GetFamilyByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetFamilyByID(ctx context.Context, id uuid.UUID) (database.Family, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetFamilyByID")
	}

	var r0 database.Family
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (database.Family, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) database.Family); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(database.Family)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetFamilyByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFamilyByID'
type MockStore_GetFamilyByID_Call struct {
	*mock.Call
}

// GetFamilyByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetFamilyByID(ctx interface{}, id interface{}) *MockStore_GetFamilyByID_Call {
	return &MockStore_GetFamilyByID_Call{Call: _e.mock.On("GetFamilyByID", ctx, id)}
}

func (_c *MockStore_GetFamilyByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_GetFamilyByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetFamilyByID_Call) Return(_a0 database.Family, _a1 error) *MockStore_GetFamilyByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetFamilyByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (database.Family, error)) *MockStore_GetFamilyByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetFamilyByUserID provides a mock function with given fields: ctx, createdByUserID
func (_m *MockStore) GetFamilyByUserID(ctx context.Context, createdByUserID uuid.UUID) (database.Family, error) {
	ret := _m.Called(ctx, createdByUserID)

	if len(ret) == 0 {
		panic("no return value specified for GetFamilyByUserID")
	}

	var r0 database.Family
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (database.Family, error)); ok {
		return rf(ctx, createdByUserID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) database.Family); ok {
		r0 = rf(ctx, createdByUserID)
	} else {
		r0 = ret.Get(0).(database.Family)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, createdByUserID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetFamilyByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFamilyByUserID'
type MockStore_GetFamilyByUserID_Call struct {
	*mock.Call
}

// GetFamilyByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - createdByUserID uuid.UUID
func (_e *MockStore_Expecter) GetFamilyByUserID(ctx interface{}, createdByUserID interface{}) *MockStore_GetFamilyByUserID_Call {
	return &MockStore_GetFamilyByUserID_Call{Call: _e.mock.On("GetFamilyByUserID", ctx, createdByUserID)}
}

func (_c *MockStore_GetFamilyByUserID_Call) Run(run func(ctx context.Context, createdByUserID uuid.UUID)) *MockStore_GetFamilyByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetFamilyByUserID_Call) Return(_a0 database.Family, _a1 error) *MockStore_GetFamilyByUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetFamilyByUserID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (database.Family, error)) *MockStore_GetFamilyByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngredientByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetIngredientByID(ctx context.Context, id int32) (database.Ingredient, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetIngredientByID")
	}

	var r0 database.Ingredient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32) (database.Ingredient, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32) database.Ingredient); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(database.Ingredient)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetIngredientByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngredientByID'
type MockStore_GetIngredientByID_Call struct {
	*mock.Call
}

// GetIngredientByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int32
func (_e *MockStore_Expecter) GetIngredientByID(ctx interface{}, id interface{}) *MockStore_GetIngredientByID_Call {
	return &MockStore_GetIngredientByID_Call{Call: _e.mock.On("GetIngredientByID", ctx, id)}
}

func (_c *MockStore_GetIngredientByID_Call) Run(run func(ctx context.Context, id int32)) *MockStore_GetIngredientByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32))
	})
	return _c
}

func (_c *MockStore_GetIngredientByID_Call) Return(_a0 database.Ingredient, _a1 error) *MockStore_GetIngredientByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetIngredientByID_Call) RunAndReturn(run func(context.Context, int32) (database.Ingredient, error)) *MockStore_GetIngredientByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngredientByName provides a mock function with given fields: ctx, name
func (_m *MockStore) GetIngredientByName(ctx context.Context, name string) (database.Ingredient, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetIngredientByName")
	}

	var r0 database.Ingredient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (database.Ingredient, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) database.Ingredient); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(database.Ingredient)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetIngredientByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngredientByName'
type MockStore_GetIngredientByName_Call struct {
	*mock.Call
}

// GetIngredientByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockStore_Expecter) GetIngredientByName(ctx interface{}, name interface{}) *MockStore_GetIngredientByName_Call {
	return &MockStore_GetIngredientByName_Call{Call: _e.mock.On("GetIngredientByName", ctx, name)}
}

func (_c *MockStore_GetIngredientByName_Call) Run(run func(ctx context.Context, name string)) *MockStore_GetIngredientByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetIngredientByName_Call) Return(_a0 database.Ingredient, _a1 error) *MockStore_GetIngredientByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetIngredientByName_Call) RunAndReturn(run func(context.Context, string) (database.Ingredient, error)) *MockStore_GetIngredientByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngredients provides a mock function with given fields: ctx
func (_m *MockStore) GetIngredients(ctx context.Context) ([]database.Ingredient, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetIngredients")
	}

	var r0 []database.Ingredient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.Ingredient, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.Ingredient); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Ingredient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetIngredients_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngredients'
type MockStore_GetIngredients_Call struct {
	*mock.Call
}

// GetIngredients is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetIngredients(ctx interface{}) *MockStore_GetIngredients_Call {
	return &MockStore_GetIngredients_Call{Call: _e.mock.On("GetIngredients", ctx)}
}

func (_c *MockStore_GetIngredients_Call) Run(run func(ctx context.Context)) *MockStore_GetIngredients_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_GetIngredients_Call) Return(_a0 []database.Ingredient, _a1 error) *MockStore_GetIngredients_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetIngredients_Call) RunAndReturn(run func(context.Context) ([]database.Ingredient, error)) *MockStore_GetIngredients_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecipeByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetRecipeByID(ctx context.Context, id uuid.UUID) (database.Recipe, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetRecipeByID")
	}

	var r0 database.Recipe
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (database.Recipe, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) database.Recipe); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(database.Recipe)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetRecipeByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecipeByID'
type MockStore_GetRecipeByID_Call struct {
	*mock.Call
}

// GetRecipeByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetRecipeByID(ctx interface{}, id interface{}) *MockStore_GetRecipeByID_Call {
	return &MockStore_GetRecipeByID_Call{Call: _e.mock.On("GetRecipeByID", ctx, id)}
}

func (_c *MockStore_GetRecipeByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_GetRecipeByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetRecipeByID_Call) Return(_a0 database.Recipe, _a1 error) *MockStore_GetRecipeByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetRecipeByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (database.Recipe, error)) *MockStore_GetRecipeByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecipes provides a mock function with given fields: ctx
func (_m *MockStore) GetRecipes(ctx context.Context) ([]database.Recipe, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRecipes")
	}

	var r0 []database.Recipe
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.Recipe, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.Recipe); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Recipe)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetRecipes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecipes'
type MockStore_GetRecipes_Call struct {
	*mock.Call
}

// GetRecipes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetRecipes(ctx interface{}) *MockStore_GetRecipes_Call {
	return &MockStore_GetRecipes_Call{Call: _e.mock.On("GetRecipes", ctx)}
}

func (_c *MockStore_GetRecipes_Call) Run(run func(ctx context.Context)) *MockStore_GetRecipes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_GetRecipes_Call) Return(_a0 []database.Recipe, _a1 error) *MockStore_GetRecipes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetRecipes_Call) RunAndReturn(run func(context.Context) ([]database.Recipe, error)) *MockStore_GetRecipes_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecipesByFamilyID provides a mock function with given fields: ctx, familyID
func (_m *MockStore) GetRecipesByFamilyID(ctx context.Context, familyID uuid.UUID) ([]database.Recipe, error) {
	ret := _m.Called(ctx, familyID)

	if len(ret) == 0 {
		panic("no return value specified for GetRecipesByFamilyID")
	}

	var r0 []database.Recipe
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]database.Recipe, error)); ok {
		return rf(ctx, familyID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []database.Recipe); ok {
		r0 = rf(ctx, familyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Recipe)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, familyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetRecipesByFamilyID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecipesByFamilyID'
type MockStore_GetRecipesByFamilyID_Call struct {
	*mock.Call
}

// GetRecipesByFamilyID is a helper method to define mock.On call
//   - ctx context.Context
//   - familyID uuid.UUID
func (_e *MockStore_Expecter) GetRecipesByFamilyID(ctx interface{}, familyID interface{}) *MockStore_GetRecipesByFamilyID_Call {
	return &MockStore_GetRecipesByFamilyID_Call{Call: _e.mock.On("GetRecipesByFamilyID", ctx, familyID)}
}

func (_c *MockStore_GetRecipesByFamilyID_Call) Run(run func(ctx context.Context, familyID uuid.UUID)) *MockStore_GetRecipesByFamilyID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetRecipesByFamilyID_Call) Return(_a0 []database.Recipe, _a1 error) *MockStore_GetRecipesByFamilyID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetRecipesByFamilyID_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]database.Recipe, error)) *MockStore_GetRecipesByFamilyID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *MockStore) GetUserByEmail(ctx context.Context, email string) (database.User, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (database.User, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) database.User); ok {
		r0 = rf(ctx, email)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockStore_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockStore_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *MockStore_GetUserByEmail_Call {
	return &MockStore_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *MockStore_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *MockStore_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetUserByEmail_Call) Return(_a0 database.User, _a1 error) *MockStore_GetUserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string) (database.User, error)) *MockStore_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetUserByID(ctx context.Context, id uuid.UUID) (database.User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (database.User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) database.User); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type MockStore_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetUserByID(ctx interface{}, id interface{}) *MockStore_GetUserByID_Call {
	return &MockStore_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, id)}
}

func (_c *MockStore_GetUserByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetUserByID_Call) Return(_a0 database.User, _a1 error) *MockStore_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetUserByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (database.User, error)) *MockStore_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsers provides a mock function with given fields: ctx
func (_m *MockStore) GetUsers(ctx context.Context) ([]database.User, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetUsers")
	}

	var r0 []database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.User, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.User); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsers'
type MockStore_GetUsers_Call struct {
	*mock.Call
}

// GetUsers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetUsers(ctx interface{}) *MockStore_GetUsers_Call {
	return &MockStore_GetUsers_Call{Call: _e.mock.On("GetUsers", ctx)}
}

func (_c *MockStore_GetUsers_Call) Run(run func(ctx context.Context)) *MockStore_GetUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_GetUsers_Call) Return(_a0 []database.User, _a1 error) *MockStore_GetUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetUsers_Call) RunAndReturn(run func(context.Context) ([]database.User, error)) *MockStore_GetUsers_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateFamily provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateFamily(ctx context.Context, arg database.UpdateFamilyParams) (database.Family, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFamily")
	}

	var r0 database.Family
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateFamilyParams) (database.Family, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateFamilyParams) database.Family); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Family)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateFamilyParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateFamily_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateFamily'
type MockStore_UpdateFamily_Call struct {
	*mock.Call
}

// UpdateFamily is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateFamilyParams
func (_e *MockStore_Expecter) UpdateFamily(ctx interface{}, arg interface{}) *MockStore_UpdateFamily_Call {
	return &MockStore_UpdateFamily_Call{Call: _e.mock.On("UpdateFamily", ctx, arg)}
}

func (_c *MockStore_UpdateFamily_Call) Run(run func(ctx context.Context, arg database.UpdateFamilyParams)) *MockStore_UpdateFamily_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateFamilyParams))
	})
	return _c
}

func (_c *MockStore_UpdateFamily_Call) Return(_a0 database.Family, _a1 error) *MockStore_UpdateFamily_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateFamily_Call) RunAndReturn(run func(context.Context, database.UpdateFamilyParams) (database.Family, error)) *MockStore_UpdateFamily_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIngredient provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateIngredient(ctx context.Context, arg database.UpdateIngredientParams) (database.Ingredient, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIngredient")
	}

	var r0 database.Ingredient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateIngredientParams) (database.Ingredient, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateIngredientParams) database.Ingredient); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Ingredient)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateIngredientParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateIngredient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIngredient'
type MockStore_UpdateIngredient_Call struct {
	*mock.Call
}

// UpdateIngredient is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateIngredientParams
func (_e *MockStore_Expecter) UpdateIngredient(ctx interface{}, arg interface{}) *MockStore_UpdateIngredient_Call {
	return &MockStore_UpdateIngredient_Call{Call: _e.mock.On("UpdateIngredient", ctx, arg)}
}

func (_c *MockStore_UpdateIngredient_Call) Run(run func(ctx context.Context, arg database.UpdateIngredientParams)) *MockStore_UpdateIngredient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateIngredientParams))
	})
	return _c
}

func (_c *MockStore_UpdateIngredient_Call) Return(_a0 database.Ingredient, _a1 error) *MockStore_UpdateIngredient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateIngredient_Call) RunAndReturn(run func(context.Context, database.UpdateIngredientParams) (database.Ingredient, error)) *MockStore_UpdateIngredient_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRecipe provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateRecipe(ctx context.Context, arg database.UpdateRecipeParams) (database.Recipe, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRecipe")
	}

	var r0 database.Recipe
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateRecipeParams) (database.Recipe, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateRecipeParams) database.Recipe); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.Recipe)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateRecipeParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateRecipe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRecipe'
type MockStore_UpdateRecipe_Call struct {
	*mock.Call
}

// UpdateRecipe is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateRecipeParams
func (_e *MockStore_Expecter) UpdateRecipe(ctx interface{}, arg interface{}) *MockStore_UpdateRecipe_Call {
	return &MockStore_UpdateRecipe_Call{Call: _e.mock.On("UpdateRecipe", ctx, arg)}
}

func (_c *MockStore_UpdateRecipe_Call) Run(run func(ctx context.Context, arg database.UpdateRecipeParams)) *MockStore_UpdateRecipe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateRecipeParams))
	})
	return _c
}

func (_c *MockStore_UpdateRecipe_Call) Return(_a0 database.Recipe, _a1 error) *MockStore_UpdateRecipe_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateRecipe_Call) RunAndReturn(run func(context.Context, database.UpdateRecipeParams) (database.Recipe, error)) *MockStore_UpdateRecipe_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserEmail provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateUserEmail(ctx context.Context, arg database.UpdateUserEmailParams) (database.User, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserEmail")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserEmailParams) (database.User, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserEmailParams) database.User); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateUserEmailParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateUserEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserEmail'
type MockStore_UpdateUserEmail_Call struct {
	*mock.Call
}

// UpdateUserEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateUserEmailParams
func (_e *MockStore_Expecter) UpdateUserEmail(ctx interface{}, arg interface{}) *MockStore_UpdateUserEmail_Call {
	return &MockStore_UpdateUserEmail_Call{Call: _e.mock.On("UpdateUserEmail", ctx, arg)}
}

func (_c *MockStore_UpdateUserEmail_Call) Run(run func(ctx context.Context, arg database.UpdateUserEmailParams)) *MockStore_UpdateUserEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateUserEmailParams))
	})
	return _c
}

func (_c *MockStore_UpdateUserEmail_Call) Return(_a0 database.User, _a1 error) *MockStore_UpdateUserEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateUserEmail_Call) RunAndReturn(run func(context.Context, database.UpdateUserEmailParams) (database.User, error)) *MockStore_UpdateUserEmail_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserInfo provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateUserInfo(ctx context.Context, arg database.UpdateUserInfoParams) (database.User, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserInfo")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserInfoParams) (database.User, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserInfoParams) database.User); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateUserInfoParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateUserInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserInfo'
type MockStore_UpdateUserInfo_Call struct {
	*mock.Call
}

// UpdateUserInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateUserInfoParams
func (_e *MockStore_Expecter) UpdateUserInfo(ctx interface{}, arg interface{}) *MockStore_UpdateUserInfo_Call {
	return &MockStore_UpdateUserInfo_Call{Call: _e.mock.On("UpdateUserInfo", ctx, arg)}
}

func (_c *MockStore_UpdateUserInfo_Call) Run(run func(ctx context.Context, arg database.UpdateUserInfoParams)) *MockStore_UpdateUserInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateUserInfoParams))
	})
	return _c
}

func (_c *MockStore_UpdateUserInfo_Call) Return(_a0 database.User, _a1 error) *MockStore_UpdateUserInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateUserInfo_Call) RunAndReturn(run func(context.Context, database.UpdateUserInfoParams) (database.User, error)) *MockStore_UpdateUserInfo_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserPassword provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateUserPassword(ctx context.Context, arg database.UpdateUserPasswordParams) (database.User, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserPassword")
	}

	var r0 database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserPasswordParams) (database.User, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.UpdateUserPasswordParams) database.User); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(database.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.UpdateUserPasswordParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateUserPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserPassword'
type MockStore_UpdateUserPassword_Call struct {
	*mock.Call
}

// UpdateUserPassword is a helper method to define mock.On call
//   - ctx context.Context
//   - arg database.UpdateUserPasswordParams
func (_e *MockStore_Expecter) UpdateUserPassword(ctx interface{}, arg interface{}) *MockStore_UpdateUserPassword_Call {
	return &MockStore_UpdateUserPassword_Call{Call: _e.mock.On("UpdateUserPassword", ctx, arg)}
}

func (_c *MockStore_UpdateUserPassword_Call) Run(run func(ctx context.Context, arg database.UpdateUserPasswordParams)) *MockStore_UpdateUserPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.UpdateUserPasswordParams))
	})
	return _c
}

func (_c *MockStore_UpdateUserPassword_Call) Return(_a0 database.User, _a1 error) *MockStore_UpdateUserPassword_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateUserPassword_Call) RunAndReturn(run func(context.Context, database.UpdateUserPasswordParams) (database.User, error)) *MockStore_UpdateUserPassword_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
